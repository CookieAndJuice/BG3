 좋아요. PlayerController에 부착하는 MouseInputComponent로 “커서 → 타겟 지정 / 확인키 → 확정”을 처리하는 접근, 3주 범위에 딱 맞고 깔
  끔합니다. 그래서 바로 컴포넌트를 추가하고 컨트롤러에 연결해두었습니다.

  추가/변경 사항

  - 새 컴포넌트: UMouseInputComponent
      - 경로: Source/BG3/Public/Component/MouseInputComponent.h, Source/BG3/Private/Component/MouseInputComponent.cpp
      - 역할:
      - 클릭 시 커서 아래 액터 하나를 트레이스로 획득 → `USkillExecutionSubsystem::SetTargets(...)`
      - 확인 액션 → `ConfirmAndExecute(CurrentRound)` 호출(현재 0 전달; 턴 시스템 완성 시 값 연결)
      - 취소 액션 → `CancelCast()` 호출
  - 상태 가드: Subsystem이 Targeting 상태일 때만 동작
  - Enhanced Input 연동: BindInput(UEnhancedInputComponent* EIC) 제공. 컴포넌트에 ClickAction/ConfirmAction/CancelAction 액션 에셋을
  세팅하면 바인딩합니다.
  - 컨트롤러 연결: ABG3GameModePlayerController
      - 헤더에 UMouseInputComponent* MouseInput 추가
      - 생성자에서 CreateDefaultSubobject<UMouseInputComponent>()
      - SetupInputComponent()에서 MouseInput->BindInput(EIC) 호출
      - 변경 파일:
      - `Source/BG3/Public/Controller/BG3GameModePlayerController.h`
      - `Source/BG3/Private/Controller/BG3GameModePlayerController.cpp`

  입력 바인딩 가이드

  - 액션 에셋(에디터에서 세팅)
      - ClickAction: Left Mouse Button
      - ConfirmAction: Enter / Space / Right Mouse Button 중 하나
      - CancelAction: Escape
  - Enhanced Input IMC는 기존처럼 컨트롤러에서 등록하고, 실제 바인딩은 SetupInputComponent에서 컴포넌트의 BindInput로 위임했습니다.
  - 커서 트레이스: APlayerController::GetHitResultUnderCursorByChannel(ECC_Visibility, true, Hit) 사용

  동작 흐름(권장)

  - 스킬 버튼 클릭 → USkillExecutionSubsystem::RequestCast(이미 UI에서 호출)
  - Targeting 상태에서:
      - 클릭 → MouseInputComponent::OnClick가 커서 아래 액터 1명으로 SetTargets
      - Confirm → ConfirmAndExecute(0) 호출(임시 라운드값)
      - Cancel → CancelCast
  - 사거리/최대 타겟 수는 Subsystem의 SetTargets에서 필터링합니다.

  확장 포인트

  - 멀티타겟/원형: 클릭을 누적(배열 유지)하거나, 커서 위치 기준 SphereOverlapActors로 후보 수집 → SetTargets.
  - 프리뷰: 마우스 이동 시점에 주기적으로 커서 아래 후보를 SetTargets로 갱신해도 됩니다(또는 별도 TargetsUpdated 연결).
  - 근접 애니 연동: 공격 몽타주의 히트 노티파이에서 ConfirmAndExecute(CurrentRound) 호출. 현재 구현은 “확정=명중” 모델이므로 잘 맞습
  니다.

  주의사항

  - 현재 ConfirmAndExecute는 라운드값에 0을 넣습니다. 턴 시스템에서 라운드 관리되면 해당 값을 넘기도록 바꾸면 됩니다.
  - 액션 에셋은 코드에 하드참조하지 않았습니다(에디터에서 세팅). 원하면 컨트롤러와 같은 방식으로 ConstructorHelpers로 기본 에셋을 찾
  아 세팅해드릴 수 있어요.

  원하시면

  - 원형 타겟팅/중복 선택(Shift-클릭)과 간단 프리뷰까지 바로 붙여드릴게요.
  - Confirm 시 d20 명중 체크(임시 AC 비교)도 가볍게 넣을 수 있습니다.

▌근데 스킬 UI를 누르면 Targeting 상태이잖아. 그리고 ClickAction에서 해당 마우스 커서 아래에 있는 액터를 트레이스해서 가져오게 되잖아.
▌(또는 해당 지점에 SphereOverlapActors) 그리고 그 후에 SetTargets 하고, SetTargets 일어난 후에 Confirm 이 되어야 하는거 아니야? 너가
▌설계한거는 Enter나 Space, Right Mouse Button을 누르면 Confirm Action이 일어나도록 설계한건데, 나는 이미 타겟팅 시점에서 타겟 위에 마
▌우스 커서를 올리고 OnClicked 됐을 때가 SetTargets과 동시에 ConfirmAndExecute 가 일어난다고 생각했어. 내가 이해한게 맞아? 내 허락 받
▌기 전까지는 코드 수정하지 말고 그냥 물어보면 설명만 해줘

> 결론: 네, “타겟팅 중 클릭 한 번 = SetTargets 후 즉시 ConfirmAndExecute” 흐름으로 써도 맞습니다. 지금 Subsystem은 별도 확정 키가 필
  수는 아니며, OnClick에서 두 호출을 연달아 해도 정상 동작합니다.

  두 가지 입력 모델 비교

  - 한 번 클릭 확정(네가 말한 방식)
      - 장점: 빠름, 단일 대상/간단 스킬에 적합.
      - 단점: 오입력/미리보기 없이 즉시 소모, 다중 대상/지면(AoE) 정밀 선택에 불리.
  - 두 단계(클릭으로 선택 → 별도 확정 키)
      - 장점: 미리보기/수정/취소 기회 확보, 다중 타겟·원형 지면 지정에 유리.
      - 단점: 입력이 1회 더 들어감.

  권장 적용 기준

  - 근접·단일 타겟: 클릭 시 SetTargets → ConfirmAndExecute 즉시 실행이 편함.
  Implement {feature}                                                                                                               
  - 애니메이션 싱크(근접 타이밍 히트): 클릭 시 SetTargets만 하고, AnimNotify에서 ConfirmAndExecute 호출이 가장 자연스러움.
  - 다중 타겟 선택형: 클릭은 SetTargets 누적, 별도 확정으로 마감.

  현재 구조에서 구현 포인트(설명만)

  - MouseInputComponent.OnClick:
      - 커서 트레이스로 액터를 찾은 뒤
      - SES->SetTargets({HitActor});
      - 즉시 SES->ConfirmAndExecute(CurrentRound); 호출하면 한 번 클릭 확정이 됩니다.
  - 지면 지정형(원형): 커서 위치를 기준으로 SphereOverlapActors로 후보 수집 → SetTargets → 즉시 ConfirmAndExecute.
  - 애니 싱크형: OnClick에서 타겟만 넘기고 몽타주 재생, 히트 노티파이에서 ConfirmAndExecute.
  - 가드/피드백:
      - SetTargets 후 실제 유효 타겟이 비어지면 Confirm 호출을 건너뛰는 것이 안전.
      - SES->IsBusy()/GetCastState()==Targeting 체크로 오작동 방지.
      - 취소 입력 시 CancelCast() 호출.

  선택적 개선

  - 스킬별 입력 모드: USkillDefinition에 “ConfirmOnClick” 또는 “TargetingConfirmMode” 추가해 스킬마다 한 번 클릭 확정/두 단계 확정을
  선택 가능.
  - UI 프리뷰: 마우스 이동 중에도 후보를 SetTargets로 갱신하여 하이라이트만 하고, 클릭 시 확정.

  현재는 네가 원하는 방식(클릭=선정+확정)으로 충분히 사용 가능하며, 애니 싱크가 필요한 근접기는 노티파이에서 Confirm으로 전환하면 됩
  니다. 원하시면 이 로직을 MouseInputComponent에 반영하는 패치를 준비해 드릴게요.

▌지면/원형(AoE)의 경우에도, 타겟팅 시에 마우스 커서 위치에 미리보기 생성하잖아. 그리고 그 위치에서 왼쪽 마우스 누르면, 그 위치의 액터
▌들로 SetTargets 되도록 하려는데, 이것도 미리보기가 들어갈 뿐이지 사실은 1단계 아니야? 너가 두 단계라고 하니깐 헷갈려

> 맞아요. 지면/원형(AoE)에서 “마우스 이동 중 미리보기 → 왼쪽 클릭 시 그 위치의 액터들로 SetTargets → 즉시 ConfirmAndExecute”라면 입력
  적으로는 1단계(한 번 클릭 확정)입니다. 제가 말한 “두 단계”는 “미리보기(또는 위치 선택) 후 별도의 확정 입력(다시 클릭/Enter)”이 있는
  경우를 말한 것이고, 미리보기가 있다고 해서 반드시 두 단계라는 뜻은 아닙니다.

  모델 구분

  - 한 번 클릭 확정(단일/원형 공통)
      - 마우스 이동: 미리보기만 갱신(클라이언트 프리뷰)
      - 왼쪽 클릭: 해당 위치 기준 대상 계산 → SetTargets → ConfirmAndExecute
  - 두 단계 확정(선택 사항)
      - 마우스 이동: 미리보기 갱신
      - 왼쪽 클릭: 위치 고정 또는 후보 저장(아직 실행 안 함)
      - Enter/다시 클릭: ConfirmAndExecute 실행
      - 장점: 고비용 스킬, 다중 배치, 정밀 조준에서 실수 방지

  권장 매핑(너가 원하는 방식)

  - 근접/단일: 클릭 시 SetTargets({HitActor}) → 필요 시 AnimNotify에서 ConfirmAndExecute(애니 싱크) 또는 즉시 ConfirmAndExecute
  - 원형(AoE): 마우스 이동 중 프리뷰(겹치는 액터 하이라이트)
      - 왼쪽 클릭: 커서 위치에서 SphereOverlapActors → SetTargets(Targets) → 즉시 ConfirmAndExecute

  입력 컴포넌트 동작 개념

  - OnMouseMove: 프리뷰만 갱신(Subsystem 호출 없이 로컬 계산/하이라이트)
  - OnClick(LMB):
      - 단일: 트레이스 액터 → SetTargets → ConfirmAndExecute
      - 원형: 커서 위치 오버랩 → SetTargets → ConfirmAndExecute
  - 필요 시 스킬별 정책:
      - “ConfirmOnClick” 같은 플래그(스킬 데이터/설정)에 따라 클릭 즉시 확정 vs 별도 확정 키 선택